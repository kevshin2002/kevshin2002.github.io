"use strict";(self.webpackChunkkevshin2002=self.webpackChunkkevshin2002||[]).push([[1890],{701:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Software/C++/eff_modern_cpp","title":"Effective Modern C++","description":"Preface","source":"@site/docs/Software/C++/eff_modern.mdx","sourceDirName":"Software/C++","slug":"/Software/C++/eff_modern_cpp","permalink":"/docs/Software/C++/eff_modern_cpp","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1739865600000,"sidebarPosition":1,"frontMatter":{"id":"eff_modern_cpp","title":"Effective Modern C++","hide_title":true,"sidebar_position":1,"last_update":{"date":"2/18/2025","author":"Kevin Shin"}},"sidebar":"noteSidebar","previous":{"title":"Search","permalink":"/docs/note"},"next":{"title":"Machine Learning","permalink":"/docs/Machine-Learning/"}}');var r=t(4848),a=t(8453);const i={id:"eff_modern_cpp",title:"Effective Modern C++",hide_title:!0,sidebar_position:1,last_update:{date:"2/18/2025",author:"Kevin Shin"}},o=void 0,c={},d=[{value:"<strong>Preface</strong>",id:"preface",level:2},{value:"<strong>Deducing Types</strong>",id:"deducing-types",level:2},{value:"<strong>Understanding template type deduction</strong>",id:"understanding-template-type-deduction",level:3},{value:"<strong>Case 1: <strong>ParamType</strong> is a Reference or Pointer, but not a Universal Reference</strong>",id:"case-1-paramtype-is-a-reference-or-pointer-but-not-a-universal-reference",level:4},{value:"<strong>Case 2: <strong>ParamType</strong> is a Universal Reference</strong>",id:"case-2-paramtype-is-a-universal-reference",level:4},{value:"<strong>Case 3: <strong>ParamType</strong> is neither a pointer nor a reference</strong>",id:"case-3-paramtype-is-neither-a-pointer-nor-a-reference",level:4},{value:"<strong>Array Arguments</strong>",id:"array-arguments",level:4}];function l(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"preface",children:(0,r.jsx)(n.strong,{children:"Preface"})}),"\n",(0,r.jsx)(n.p,{children:'The note is based off of Scott Meyers famous book titled "Effective Modern C++". In it, he details the workings of C+11 and C+14 and how to become a better software engineer.'}),"\n",(0,r.jsx)(n.h2,{id:"deducing-types",children:(0,r.jsx)(n.strong,{children:"Deducing Types"})}),"\n",(0,r.jsxs)(n.p,{children:["In C++98, there was a single set of rules for type deduction which was for function templates. In C++11, those rules were modified and extended: one for ",(0,r.jsx)(n.code,{children:"auto"}),", and another for ",(0,r.jsx)(n.code,{children:"decltype"}),". C++14 extended the usage for ",(0,r.jsx)(n.code,{children:"auto"})," and ",(0,r.jsx)(n.code,{children:"decltype"}),". I am guilty of using the keyword ",(0,r.jsx)(n.code,{children:"auto"})," frequently without realizing the underlying implementation that makes it possible. This is because it minimizes having to type out the type constantly as changing the type at initialization can propagate throughout the program. Despite that, the types deduced by the compiler via the usage ",(0,r.jsx)(n.code,{children:"auto"})," may not be as what we want it to be."]}),"\n",(0,r.jsxs)(n.p,{children:["As such, the only way to be effective at using ",(0,r.jsx)(n.code,{children:"auto"})," is to understand how it works. This section explains template type deduction, building ",(0,r.jsx)(n.code,{children:"auto"})," on top of it, and the tangent of ",(0,r.jsx)(n.code,{children:"decltype"}),". Scott also explains how we can force compilers to make the results of their type deduction visible, and allows us to guarantee that the compilers are deducing the types we want them to be deducing."]}),"\n",(0,r.jsx)(n.h3,{id:"understanding-template-type-deduction",children:(0,r.jsx)(n.strong,{children:"Understanding template type deduction"})}),"\n",(0,r.jsxs)(n.p,{children:["C++ developers are guilty of using templates without knowing how it works. The reality is that the rules for template type deduction are employed by the ",(0,r.jsx)(n.code,{children:"auto"})," keyword. A function template looks like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T>\nvoid f(ParamType param);\n\nf(expr); // Function call\n"})}),"\n",(0,r.jsxs)(n.p,{children:["During compilation, compilers will use ",(0,r.jsx)(n.code,{children:"expr"})," to deduce the types of ",(0,r.jsx)(n.code,{children:"T"})," and ",(0,r.jsx)(n.code,{children:"ParamType"}),".The reason why we deduce both types is that ",(0,r.jsx)(n.code,{children:"ParamType"})," contains adornments such as the usage of ",(0,r.jsx)(n.code,{children:"const"})," or ",(0,r.jsx)(n.code,{children:"reference qualifiers"}),". If we instead modified the function to this below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nvoid f(const T& param);\n\nint x = 0;\nf(x) // Type deduced for param will be const int& even though we send in an int, but T will be an int.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It's also expected that most would assume ",(0,r.jsx)(n.code,{children:"T"})," deduction will always be the same type as the argument passed to the function, but that's not always the case. The type deduced for T is dependent not just on the type of expression passed in, but also on the form of ",(0,r.jsx)(n.code,{children:"ParamType"})," as we saw."]}),"\n",(0,r.jsx)(n.p,{children:"There are three cases:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ParamType"})," is a pointer or reference type but not a universal reference. This is not the same as lvalue or rvalue references."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ParamType"})," is a universal reference."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ParamType"})," is neither a pointer nor a reference."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"case-1-paramtype-is-a-reference-or-pointer-but-not-a-universal-reference",children:(0,r.jsxs)(n.strong,{children:["Case 1: ",(0,r.jsx)(n.strong,{children:"ParamType"})," is a Reference or Pointer, but not a Universal Reference"]})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.strong,{children:"ParamType"})," is a reference or pointer type, ",(0,r.jsx)(n.em,{children:"but"})," not a universal reference, then type deduction works as follows:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"If the expression is a reference, ignore the reference part."}),"\n",(0,r.jsxs)(n.li,{children:["Pattern-match the expression's type against ",(0,r.jsx)(n.strong,{children:"ParamType"})," to determine T."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T>\nvoid f(T& param); // reference\n\nint x = 27; // int\nconst int cx = x; // const int\nconst int& rx = x; // reference const int\n\nf(x) // T is int, param is int&\nf(cx) // T is const int, param is const int&\nf(rx) // T is const int, param is const int&\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note the second and third function calls. They both remain ",(0,r.jsx)(n.strong,{children:"const"})," even though the parameter is of reference type. This means that passing in a ",(0,r.jsx)(n.strong,{children:"const"})," object to a reference parameter is safe as the ",(0,r.jsx)(n.strong,{children:"constness"})," of an object comes part of the type deduced for T."]}),"\n",(0,r.jsx)(n.p,{children:"These examples use lvalue references, but type deduction works exactly the same way for rvalue references. The only difference is that the parameters has to be rvalue references and this has nothing to do with type deduction protocol."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T>\nvoid f(const T& param); // reference to const\n\nint x = 27;\nconst int cx = x;\nconst int& rx = x;\n\nf(x); // T is int, param is const int&\nf(cx); // T is int, param is const int&\nf(rx); // T is int, param is const int&\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We drop the ",(0,r.jsx)(n.strong,{children:"constness"})," on T because our parameter is now a reference to ",(0,r.jsx)(n.strong,{children:"const"})," and no longer a need for T to have ",(0,r.jsx)(n.strong,{children:"const"}),". Note that if we dropped the const term, it would implictly enforce ",(0,r.jsx)(n.strong,{children:"constness"})," but explictly stating that the parameter is ",(0,r.jsx)(n.strong,{children:"const"})," does the same thing, except now param is always a reference to const."]}),"\n",(0,r.jsx)(n.p,{children:"Pointer case is the exact same, but instead of a reference, we have a pointer."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nvoid f(T* param);\n\nint x = 27;\nconst int *px = x;\nf(&x); // T is int, param is int*\nf(px); // T is const int, param is const int*\n"})}),"\n",(0,r.jsx)(n.h4,{id:"case-2-paramtype-is-a-universal-reference",children:(0,r.jsxs)(n.strong,{children:["Case 2: ",(0,r.jsx)(n.strong,{children:"ParamType"})," is a Universal Reference"]})}),"\n",(0,r.jsxs)(n.p,{children:["A universal reference declared type is ",(0,r.jsx)(n.strong,{children:"T&&"})," and can take both lvalue references and rvalue references. What kind of reference changes inside of the function scope though once passed in."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["If expression is an lvalue, both ",(0,r.jsx)(n.strong,{children:"T"})," and ",(0,r.jsx)(n.strong,{children:"ParamType"})," are deduced to be lvalue references. This is notable as it's the only situation in template type deduction where T is deduced to be a reference. ",(0,r.jsx)(n.strong,{children:"ParamType"})," is also declared as an rvalue reference but its deduced type is an lvalue reference."]}),"\n",(0,r.jsx)(n.li,{children:"If expression is an rvalue, the normal rules apply."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T>\nvoid f(T&& param); // universal reference\n\nint x = 27;\nconst int cx = x;\nconst int& rx = x;\n\nf(x); // x is lvalue, T is int&, param is int&\nf(cx); // x is lvalue, T is const int&, param is const int&\nf(rx); // x is lvalue, t is const int&, param is const int&\nf(27); // 27 is rvalue, T is int, param is int&&\n"})}),"\n",(0,r.jsx)(n.h4,{id:"case-3-paramtype-is-neither-a-pointer-nor-a-reference",children:(0,r.jsxs)(n.strong,{children:["Case 3: ",(0,r.jsx)(n.strong,{children:"ParamType"})," is neither a pointer nor a reference"]})}),"\n",(0,r.jsx)(n.p,{children:"We're sending pass by value or a copy now. The behavior is:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"If expression is a reference, ignore the reference part."}),"\n",(0,r.jsx)(n.li,{children:"If expression is const, ignore it too. If it's volatile, ignore it too."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T>\nvoid f(T param); // pass by value\n\nint x = 27;\nconst int cx = x;\nconst int& rx = x;\n\nf(x) // T and param are both int\nf(cx) // T and param are both int\nf(rx) // T and param are both int\n"})}),"\n",(0,r.jsx)(n.p,{children:"The reason why param isn't const even though cx and rx are is because param is an entirely new copy of cx and rx. Just because the original is const doesn't mean the copy can't be. It's important that const and volatile is ignored only for pass by value parameters. For parameters that are references to or pointers to const, the constness is preserved during type deduction."}),"\n",(0,r.jsx)(n.p,{children:"Special case where expression is a const pointer to a const object, and expression is a pass by value."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'template<typename T>\nvoid f(T param);\n\nconst char* const ptr = "Fun with pointers" // left const states the strings are const, right const means the ptr can\'t be changed.\n\nf(ptr); // T is const char*\n'})}),"\n",(0,r.jsx)(n.p,{children:"When calling the function, the pointer will be copied into param, so the pointer itself is pass by value. The constness of the ptr will thus be ignored and the type deduced for param will be const char*, a modifiable pointer to a const character string. The constness of what ptr points to is preserved during type deduction but the constness of ptr is ignored as we're creating a new copy into a new pointer, param."}),"\n",(0,r.jsx)(n.h4,{id:"array-arguments",children:(0,r.jsx)(n.strong,{children:"Array Arguments"})}),"\n",(0,r.jsx)(n.p,{children:"This is pretty much it for mainstream template type deduction but there's a niche case involving array types. Many will think array types and pointer types seem interchangeable but the primary contributor is that in many contexts, an array decays into a pointer to its first element. This is what allows code like this to compile:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'const char name[] = "J, P, Briggs"; // name type is const char[13]\nconst char* ptrToName = name; // array decays to pointer\n'})}),"\n",(0,r.jsx)(n.p,{children:"These two types are not the same. One is a const char* and the other is a const char[13], but since we have array-to-pointer decay rule, the code compiles. What if an array is passed to a template taking a by-value parameter?"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nvoid f(T param); // template with pass by-value parameter\nf(name) // What would T and param types be?\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note that these two are perfectly the same:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void myFunc(int param[]);\nvoid myFunc(int* param);\n"})}),"\n",(0,r.jsx)(n.p,{children:"This equivalence of array and pointer parameters is a bit of foliage springing from the C roots at the base of C++ and it gives the illusion that array and pointer types are the same. This means that since array parameter declarations are treated as if they're pointer parameters, the type of an array that's passed to the template function by value is deduced to be a pointer type, which defaults to case 2. This means that the parameter T is deduced to be const char*."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);