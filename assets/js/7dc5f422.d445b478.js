"use strict";(self.webpackChunkkevshin2002=self.webpackChunkkevshin2002||[]).push([[3024],{9749:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Robotics/ROS2/testing-ros2","title":"Testing","description":"Getting Started","source":"@site/docs/Robotics/ROS2/testing.mdx","sourceDirName":"Robotics/ROS2","slug":"/Robotics/ROS2/testing-ros2","permalink":"/docs/Robotics/ROS2/testing-ros2","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1735113600000,"sidebarPosition":3,"frontMatter":{"id":"testing-ros2","title":"Testing","hide_title":true,"sidebar_position":3,"last_update":{"date":"12/25/2024","author":"Kevin Shin"}},"sidebar":"noteSidebar","previous":{"title":"Perception","permalink":"/docs/Robotics/ROS2/perception"},"next":{"title":"URDF","permalink":"/docs/Robotics/ROS2/urdf"}}');var r=n(4848),o=n(8453);n(1470),n(9365);const a={id:"testing-ros2",title:"Testing",hide_title:!0,sidebar_position:3,last_update:{date:"12/25/2024",author:"Kevin Shin"}},l=void 0,i={},c=[{value:"Getting Started",id:"getting-started",level:2},{value:"Testing Frameworks for ROS2",id:"testing-frameworks-for-ros2",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Library Unit Tests",id:"library-unit-tests",level:2},{value:"unittest",id:"unittest",level:3},{value:"CMakeList",id:"cmakelist",level:4},{value:"package.xml",id:"packagexml",level:4},{value:"setup.py",id:"setuppy",level:4},{value:"Test Suites",id:"test-suites",level:4},{value:"Node Tests",id:"node-tests",level:2},{value:"Automation",id:"automation",level:4},{value:"Integration Tests",id:"integration-tests-1",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,r.jsxs)(t.p,{children:["These notes are from ",(0,r.jsx)(t.a,{href:"https://app.theconstruct.ai",children:"The Construct"})," and was originally for ROS. Since they didn't have a couse on testing with ROS2, I referenced the ROS2 documentation and ChatGPT while doing this to fill in the gaps for ROS2 Testing. I used the docker image ",(0,r.jsx)(t.code,{children:"osrf/ros:humble-desktop"})," for my environment."]}),"\n",(0,r.jsx)(t.p,{children:"This note will go over:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Unit Testing"}),"\n",(0,r.jsx)(t.li,{children:"Node Level Tests"}),"\n",(0,r.jsx)(t.li,{children:"Integration Tests"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"testing-frameworks-for-ros2",children:"Testing Frameworks for ROS2"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Testing Framework"}),(0,r.jsx)(t.th,{children:"Language"}),(0,r.jsx)(t.th,{children:"Purpose"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Google Test"})}),(0,r.jsx)(t.td,{children:"C++"}),(0,r.jsx)(t.td,{children:"Unit testing with Google Test"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"pytest"})}),(0,r.jsx)(t.td,{children:"Python"}),(0,r.jsx)(t.td,{children:"Unit testing for Python-based ROS 2 nodes and library code"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"launch_testing"})}),(0,r.jsx)(t.td,{children:"Python/C++"}),(0,r.jsx)(t.td,{children:"Testing ROS 2 launch files"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"mock, unittest"})}),(0,r.jsx)(t.td,{children:"Python"}),(0,r.jsx)(t.td,{children:"Unit testing with mock and unittest"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"ros2-benchmarks"})}),(0,r.jsx)(t.td,{children:"C++/Python"}),(0,r.jsx)(t.td,{children:"Performance testing in ROS 2"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Cucumber, Behave"})}),(0,r.jsx)(t.td,{children:"Python"}),(0,r.jsx)(t.td,{children:"Behavior-driven testing (BDD)"})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:["I did not do any testing with gtest as of ",(0,r.jsx)(t.code,{children:"12/25/24"})," and this was done using ",(0,r.jsx)(t.code,{children:"unittest"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,r.jsx)(t.p,{children:"Unit tests are mainly to ensure correct functionality of a stand-alone unit or function. This means that they could test a single function, node, or process. Library unit tests are for testing non-ROS2 related issues while ROS2 unit tests are for ROS2 single nodes."}),"\n",(0,r.jsx)(t.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,r.jsx)(t.p,{children:"Integration tests are to ensure correct functionality of the system as a whole. For ROS2, it means starting up multiple nodes and ensuring that they all work as intended."}),"\n",(0,r.jsx)(t.p,{children:"I will be using the code below for all testing purposes."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\nimport time\n\nclass RobotControl(Node):\n\n    def __init__(self):\n        super().__init__('robot_control_node')\n        self.vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.cmd = Twist()\n        self.ctrl_c = False\n        self.rate = self.create_rate(10)\n        self.create_timer(0.1, self.shutdownhook)\n\n    def publish_once_in_cmd_vel(self):\n        \"\"\"\n        Publish a single Twist message to ensure command receipt.\n        \"\"\"\n        while not self.ctrl_c:\n            if self.vel_publisher.get_subscription_count() > 0:\n                self.vel_publisher.publish(self.cmd)\n                self.get_logger().info(\"Command published\")\n                break\n\t     else:\n                self.rate.sleep()\n\n    def shutdownhook(self):\n        self.stop_robot()\n        self.ctrl_c = True\n\n    def stop_robot(self):\n        self.cmd.linear.x = 0.0\n        self.cmd.angular.z = 0.0\n        self.publish_once_in_cmd_vel()\n\n    def get_inputs_rotate(self):\n        angular_speed = float(input('Enter angular speed (degrees/sec): '))\n        angle = float(input('Enter angle (degrees): '))\n        clockwise = input('Rotate clockwise? (y/n): ').strip().lower() == 'y'\n        return angular_speed, angle, clockwise\n\n    def convert_degree_to_rad(self, speed_deg, angle_deg):\n        angle = float(input('Enter angle (degrees): '))\n        clockwise = input('Rotate clockwise? (y/n): ').strip().lower() == 'y'\n        return angular_speed, angle, clockwise\n\n    def convert_degree_to_rad(self, speed_deg, angle_deg):\n        return speed_deg * 3.141592653589793 / 180, angle_deg * 3.141592653589793 / 180\n\n    def rotate(self):\n        angular_speed_d, angle_d, clockwise = self.get_inputs_rotate()\n        angular_speed_r, angle_r = self.convert_degree_to_rad(angular_speed_d, angle_d)\n\n        self.cmd.angular.z = -angular_speed_r if clockwise else angular_speed_r\n\n        start_time = self.get_clock().now()\n        current_angle = 0.0\n\n        while current_angle < angle_r:\n            self.vel_publisher.publish(self.cmd)\n            elapsed_time = self.get_clock().now() - start_time\n            current_angle = angular_speed_r * elapsed_time.nanoseconds * 1e-9\n            self.rate.sleep()\n\n        self.stop_robot()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    robot_control = RobotControl()\n    try:\n        robot_control.rotate()\n    except KeyboardInterrupt:\n        robot_control.get_logger().info(\"Shutting down gracefully.\")\n    finally:\n        robot_control.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["All tests must be within ",(0,r.jsx)(t.code,{children:"test"})," directory and must start as ",(0,r.jsx)(t.code,{children:"test_*.py"})," conventionally."]})}),"\n",(0,r.jsx)(t.h2,{id:"library-unit-tests",children:"Library Unit Tests"}),"\n",(0,r.jsx)(t.h3,{id:"unittest",children:"unittest"}),"\n",(0,r.jsxs)(t.p,{children:["Let's go ahead and create a simple unit test to see if our ",(0,r.jsx)(t.code,{children:"RobotControl"})," is behaving as correctly."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:'#!/usr/bin/env python3\n\nimport unittest # Testing framework\nimport rclpy\nfrom robot_control_py.robot_control import RobotControl\n\nclass TestRobotControl(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls): # Part of the unittest framework where we override to specify logic when we instantiate the Test Node.\n        """Initialize rclpy once for the entire test class."""\n        rclpy.init()\n\n    @classmethod\n    def tearDownClass(cls): # Part of the unittest framework where we override to specify logic for shutting down\n        """Shutdown rclpy once after all tests are complete."""\n        rclpy.shutdown()\n\n    def setUp(self): # Applies to each individual test cases and is ran before each test.\n        """Set up the test environment by creating a RobotControl node."""\n        self.rc = RobotControl()\n\n    def tearDown(self): # Applies to each after individual test case.\n        """Clean up resources after each test."""\n        self.rc.destroy_node()\n\n    def test_deg_rad_conversion(self):\n        """Test degree-to-radian conversion."""\n        speed, angle = self.rc.convert_degree_to_rad(60, 90)\n        self.assertAlmostEqual(speed, 1.0472, places=4, msg="Speed conversion failed")\n        self.assertAlmostEqual(angle, 1.57, places=2, msg="Angle conversion failed")\n\nif __name__ == \'__main__\':\n    unittest.main()\n'})}),"\n",(0,r.jsxs)(t.p,{children:["ROS2 has a built-in testing system using it's build system ",(0,r.jsx)(t.code,{children:"colcon"}),", however, to set it up, we have to configure some files. As a general rule of thumb, while ROS2 ",(0,r.jsx)(t.code,{children:"ament_python"})," is available as a build type, it's in your best interest to work with ",(0,r.jsx)(t.code,{children:"ament_cmake"})," as most ROS2 features require a ",(0,r.jsx)(t.code,{children:"CMakeLists.txt"}),"."]}),"\n",(0,r.jsx)(t.h4,{id:"cmakelist",children:"CMakeList"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-txt",children:"if(BUILD_TESTING)\n    find_package(ament_cmake_pytest REQUIRED)\n    ament_add_pytest_test(test_robot_control test/test_robot_control.py)\nendif()\n"})}),"\n",(0,r.jsx)(t.h4,{id:"packagexml",children:"package.xml"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-txt",children:"<test_depend>ament_cmake_pytest</test_depend>\n"})}),"\n",(0,r.jsx)(t.h4,{id:"setuppy",children:"setup.py"}),"\n",(0,r.jsxs)(t.p,{children:["This is only if you are using an ",(0,r.jsx)(t.code,{children:"ament_python"})," package, and is to provide the ROS2 environment where the test files are after building. Note that you will need the two above files as well."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:"(os.path.join('share', package_name, 'test'), glob('test/*.py'))\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If you don't want to utilize the ",(0,r.jsx)(t.code,{children:"colcon"})," build system, you can run the python file as a stand-alone script."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"python3 test_robot_control.py # Run without ROS2 environment\ncolcon test --packages-select <package_name> # Run with ROS2 environment\ncolcon test-result --all --verbose # Run to see results\n"})}),"\n",(0,r.jsx)(t.p,{children:"The outputs for success and failing:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-text",children:'.\n----------------------------------------------------------------------\nRan 1 test in 0.024s\n\nOK\n\n######################################################################\n\nF\n======================================================================\nFAIL: test_deg_rad_conversion (__main__.TestRobotControl)\nTest degree-to-radian conversion.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File "/ros2_ws/src/robot_control_py/test/test_robot_control.py", line 30, in test_deg_rad_conversion\n    self.assertAlmostEqual(speed, 1.0472, places=4, msg="Speed conversion failed")\nAssertionError: 0.5235987755982988 != 1.0472 within 4 places (0.5236012244017011 difference) : Speed conversion failed\nFinished <<< robot_control_py [0.63s]\nSummary: 1 package finished [0.83s]\nroot@9f3977f822c1:/ros2_ws# colcon test-result --verbose\nSummary: 1 test, 0 errors, 0 failures, 0 skipped\n'})}),"\n",(0,r.jsx)(t.h4,{id:"test-suites",children:"Test Suites"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"unittest"})," provides what's known as a Test Suite which allows us to modularize our test cases for different functionalities. Test Suites contain test cases or even other test suites."]}),"\n",(0,r.jsx)(t.p,{children:"We can create a TestSuite via below:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:'#!/usr/bin/env python3\n\nimport unittest\nimport rclpy\nfrom robot_control_py.robot_control import RobotControl\n\nclass TestCaseA(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        rclpy.init()\n\n    @classmethod\n    def tearDownClass(cls):\n        rclpy.shutdown()\n\n    def setUp(self):\n        self.rc = RobotControl()\n\n    def test_case_a(self):\n        speed, angle = self.rc.convert_degree_to_rad(60, 90)\n        self.assertAlmostEqual(angle, 1.57, places=2, msg="Test Case A failed")\n\nclass TestCaseB(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        rclpy.init()\n\n    @classmethod\n    def tearDownClass(cls):\n        rclpy.shutdown()\n\n    def setUp(self):\n        self.rc = RobotControl()\n\n    def test_case_b(self):\n        speed, angle = self.rc.convert_degree_to_rad(60, -90)\n        self.assertAlmostEqual(angle, 1.57, places=2, msg="Test Case B failed")\n'})}),"\n",(0,r.jsxs)(t.p,{children:["If we don't want to use the ",(0,r.jsx)(t.code,{children:"colcon"})," build system, we need a runner for this."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:"import unittest\nfrom test_robot_control_cases import TestCaseA, TestCaseB\n\nif __name__ == '__main__':\n    suite = unittest.TestSuite()\n    suite.addTest(TestCaseA('test_case_a'))\n    suite.addTest(TestCaseB('test_case_b'))\n    runner = unittest.TextTestRunner()\n    runner.run(suite)\n"})}),"\n",(0,r.jsx)(t.p,{children:"Output:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:'root@9f3977f822c1:/ros2_ws/src/robot_control_py/test# python3 run_tests.py\n.F\n======================================================================\nFAIL: test_case_b (test_robot_control_cases.TestCaseB)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File "/ros2_ws/src/robot_control_py/test/test_robot_control_cases.py", line 39, in test_case_b\n    self.assertAlmostEqual(angle, 1.57, places=2, msg="Test Case B failed")\nAssertionError: -1.5707963267948966 != 1.57 within 2 places (3.140796326794897 difference) : Test Case B failed                                                                                             ----------------------------------------------------------------------\nRan 2 tests in 0.054s\nFAILED (failures=1)\n'})}),"\n",(0,r.jsx)(t.p,{children:"The tests are failing because we only want positive angles but are accounting for negative angles. We can fix it by adjusting our core code and rebuilding, and doing so will pass our tests."}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["If you only want to see tests for one package, run\n",(0,r.jsx)(t.code,{children:"colcon test-result --test-result-base build/<package_name> "})]})}),"\n",(0,r.jsx)(t.p,{children:"If you want to color code it, run this command or put it inside a script file:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:'#!/bin/bash\ncolcon test --packages-select <package_name> --pytest-args="--color=yes" --pytest-args="-v" --event-handlers console_direct+\n\nroot@9f3977f822c1:/ros2_ws# ./tests.sh\nStarting >>> robot_control_py\n============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-6.2.5, py-1.10.0, pluggy-0.13.0 -- /usr/bin/python3\ncachedir: /ros2_ws/build/robot_control_py/.pytest_cache\nrootdir: /ros2_ws/src/robot_control_py, configfile: pytest.ini\nplugins: ament-flake8-0.12.11, ament-pep257-0.12.11, ament-xmllint-0.12.11, ament-copyright-0.12.11, ament-lint-0.12.11, launch-testing-ros-0.19.8, launch-testing-1.0.7, colcon-core-0.18.4\ncollecting ...\ncollected 3 items\ntest/test_robot_control_cases.py::TestCaseA::test_case_a PASSED          [ 33%]\ntest/test_robot_control_cases.py::TestCaseB::test_case_b PASSED          [ 66%]\ntest/test_robot_control_cases.py::TestCaseB::test_case_string PASSED     [100%]\n-------- generated xml file: /ros2_ws/build/robot_control_py/pytest.xml --------\n============================== 3 passed in 0.12s ===============================\nFinished <<< robot_control_py [0.63s]                                                                                                                                                                       Summary: 1 package finished [0.83s]\n'})}),"\n",(0,r.jsx)(t.h2,{id:"node-tests",children:"Node Tests"}),"\n",(0,r.jsx)(t.p,{children:"Let's do some Node Testing, which is just unit test for ROS2 nodes."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:"#!/usr/bin/env python3\n\nfrom robot_control_py.robot_control import RobotControl\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nimport time\nimport rclpy\nimport unittest\n\n\nclass TestRobotControl(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        rclpy.init()\n\n    @classmethod\n    def tearDownClass(cls):\n        rclpy.shutdown()\n\n    def setUp(self):\n        self.node = rclpy.create_node('test_robot_control_node')\n        self.rc = RobotControl()\n        self.success = False\n\n    def callback(self, msg):\n        print(f\"Received Angular Speed: {msg.angular.z}\")\n        self.success = msg.angular.z == 1.0\n\n    def test_publish_cmd_vel(self):\n        test_sub = self.node.create_subscription(\n            Twist, \"/cmd_vel\", self.callback, 10\n        )\n        self.rc.cmd.angular.z = 1.0\n        self.rc.publish_once_in_cmd_vel()\n        timeout_t = time.time() + 10.0  # 10 seconds\n\n        rclpy.spin_once(self.node, timeout_sec=0.1)\n        while not self.success and time.time() < timeout_t:\n            rclpy.spin_once(self.node, timeout_sec=0.1)\n\n        self.assertTrue(self.success)\n\n    def tearDown(self):\n        self.node.destroy_node()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"})}),"\n",(0,r.jsx)(t.p,{children:"The only difference is that before each test, we are instantiating a ROS2 node and using it within our test function. In our case, we're subscribing to /cmd_vel, and seeing if we do get a message back."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"python3 test_robot_control_node.py\n[INFO] [1735008562.793690945] [robot_control_node]: Command published\nReceived Angular Speed: 1.0\n.\n----------------------------------------------------------------------\nRan 1 test in 0.036s\n\nOK\n\n======================================================================\n./tests.sh robot_control_py\n./tests.sh robot_control_py\nStarting >>> robot_control_py\n============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-6.2.5, py-1.10.0, pluggy-0.13.0 -- /usr/bin/python3\ncachedir: /ros2_ws/build/robot_control_py/.pytest_cache\nrootdir: /ros2_ws/src/robot_control_py, configfile: pytest.ini\nplugins: ament-flake8-0.12.11, ament-pep257-0.12.11, ament-xmllint-0.12.11, ament-copyright-0.12.11, ament-lint-0.12.11, launch-testing-ros-0.19.8, launch-testing-1.0.7, colcon-core-0.18.4\ncollecting ...\ncollected 4 items\n\ntest/test_robot_control_cases.py::TestCaseA::test_case_a PASSED          [ 25%]\ntest/test_robot_control_cases.py::TestCaseB::test_case_b PASSED          [ 50%]\ntest/test_robot_control_cases.py::TestCaseB::test_case_string PASSED     [ 75%]\ntest/test_robot_control_node.py::TestRobotControl::test_publish_cmd_vel PASSED [100%]\n\n-------- generated xml file: /ros2_ws/build/robot_control_py/pytest.xml --------\n============================== 4 passed in 0.15s ===============================\nFinished <<< robot_control_py [0.67s]\n\nSummary: 1 package finished [0.89s]\n"})}),"\n",(0,r.jsx)(t.h4,{id:"automation",children:"Automation"}),"\n",(0,r.jsx)(t.p,{children:"There's actually a way simpler way where we just modify the CMakeLists and package.xml, and remove all the unnecessary stuff from main. From the ROS2 documentation,"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-txt",children:'cmake_minimum_required(VERSION 3.8)\nproject(app)\n\nif(BUILD_TESTING)\n  # Integration tests\n  find_package(ament_cmake_ros REQUIRED)\n  find_package(launch_testing_ament_cmake REQUIRED)\n  function(add_ros_isolated_launch_test path)\n    set(RUNNER "${ament_cmake_ros_DIR}/run_test_isolated.py")\n    add_launch_test("${path}" RUNNER "${RUNNER}" ${ARGN})\n  endfunction()\n  add_ros_isolated_launch_test(test/<any_test>.py)\nendif()\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:"<test_depend>ament_cmake_ros</test_depend>\n<test_depend>launch</test_depend>\n<test_depend>launch_ros</test_depend>\n<test_depend>launch_testing</test_depend>\n<test_depend>launch_testing_ament_cmake</test_depend>\n<test_depend>rclpy</test_depend>\n"})}),"\n",(0,r.jsxs)(t.p,{children:["And you can just run ",(0,r.jsx)(t.code,{children:"colcon test"})," to get your tests. I came upon this after attempting to figure out how to create launch files for testing."]}),"\n",(0,r.jsx)(t.h2,{id:"integration-tests-1",children:"Integration Tests"}),"\n",(0,r.jsxs)(t.p,{children:["We can use the same CMake file for configuring an integration test as it was built for that purpose. The ",(0,r.jsx)(t.code,{children:"add_ros_isolated_launch_test"})," isolates the nodes in order to test them. In fact, as long as our CMake file contains those lines of code, we don't have to worry about tests as long as all of our tests are in the test directory and starts with ",(0,r.jsx)(t.code,{children:"test_*.py"})]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>a});n(6540);var s=n(4164);const r={tabItem:"tabItem_Ymn6"};var o=n(4848);function a(e){let{children:t,hidden:n,className:a}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,a),hidden:n,children:t})}},1470:(e,t,n)=>{n.d(t,{A:()=>v});var s=n(6540),r=n(4164),o=n(3104),a=n(6347),l=n(205),i=n(7485),c=n(1682),d=n(679);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:n,attributes:s,default:r}}=e;return{value:t,label:n,attributes:s,default:r}}))}(n);return function(e){const t=(0,c.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function _(e){let{queryString:t=!1,groupId:n}=e;const r=(0,a.W6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,i.aZ)(o),(0,s.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=h(e),[a,i]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:o}))),[c,u]=_({queryString:n,groupId:r}),[f,m]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,d.Dv)(n);return[r,(0,s.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),g=(()=>{const e=c??f;return p({value:e,tabValues:o})?e:null})();(0,l.A)((()=>{g&&i(g)}),[g]);return{selectedValue:a,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),m(e)}),[u,m,o]),tabValues:o}}var m=n(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=n(4848);function y(e){let{className:t,block:n,selectedValue:s,selectValue:a,tabValues:l}=e;const i=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),d=e=>{const t=e.currentTarget,n=i.indexOf(t),r=l[n].value;r!==s&&(c(t),a(r))},u=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=i.indexOf(e.currentTarget)+1;t=i[n]??i[0];break}case"ArrowLeft":{const n=i.indexOf(e.currentTarget)-1;t=i[n]??i[i.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},t),children:l.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>{i.push(e)},onKeyDown:u,onClick:d,...o,className:(0,r.A)("tabs__item",g.tabItem,o?.className,{"tabs__item--active":s===t}),children:n??t},t)}))})}function x(e){let{lazy:t,children:n,selectedValue:o}=e;const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===o));return e?(0,s.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:a.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==o})))})}function j(e){const t=f(e);return(0,b.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,b.jsx)(y,{...t,...e}),(0,b.jsx)(x,{...t,...e})]})}function v(e){const t=(0,m.A)();return(0,b.jsx)(j,{...e,children:u(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var s=n(6540);const r={},o=s.createContext(r);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);