"use strict";(self.webpackChunkkevshin2002=self.webpackChunkkevshin2002||[]).push([[8399],{2088:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Software/C++/Books/eff_modern_cpp","title":"Effective Modern C++","description":"Preface","source":"@site/docs/Software/C++/Books/eff_modern.mdx","sourceDirName":"Software/C++/Books","slug":"/Software/C++/Books/eff_modern_cpp","permalink":"/docs/Software/C++/Books/eff_modern_cpp","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1734508800000,"sidebarPosition":1,"frontMatter":{"id":"eff_modern_cpp","title":"Effective Modern C++","hide_title":true,"sidebar_position":1,"last_update":{"date":"12/18/2024","author":"Kevin Shin"}},"sidebar":"noteSidebar","previous":{"title":"Search","permalink":"/docs/note"},"next":{"title":"Machine Learning","permalink":"/docs/Machine-Learning/"}}');var i=n(4848),d=n(8453);const s={id:"eff_modern_cpp",title:"Effective Modern C++",hide_title:!0,sidebar_position:1,last_update:{date:"12/18/2024",author:"Kevin Shin"}},a=void 0,r={},c=[{value:"Preface",id:"preface",level:2},{value:"Deducing Types",id:"deducing-types",level:2},{value:"Understanding template type deduction",id:"understanding-template-type-deduction",level:3}];function l(e){const t={code:"code",h2:"h2",h3:"h3",p:"p",...(0,d.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"preface",children:"Preface"}),"\n",(0,i.jsx)(t.p,{children:'The note is based off of Scott Meyers famous book titled "Effective Modern C++". In it, he details the workings of C+11 and C+14 and how to become a better software engineer.'}),"\n",(0,i.jsx)(t.h2,{id:"deducing-types",children:"Deducing Types"}),"\n",(0,i.jsxs)(t.p,{children:["In C++98, there was a single set of rules for type deduction which was for function templates. In C++11, those rules were modified and extended: one for ",(0,i.jsx)(t.code,{children:"auto"}),", and another for ",(0,i.jsx)(t.code,{children:"decltype"}),". C++14 extended the usage for ",(0,i.jsx)(t.code,{children:"auto"})," and ",(0,i.jsx)(t.code,{children:"decltype"}),". I am guilty of using the keyword ",(0,i.jsx)(t.code,{children:"auto"})," frequently without realizing the underlying implementation that makes it possible. This is because it minimizes having to type out the type constantly as changing the type at initialization can propagate throughout the program. Despite that, the types deduced by the compiler via the usage ",(0,i.jsx)(t.code,{children:"auto"})," may not be as what we want it to be."]}),"\n",(0,i.jsxs)(t.p,{children:["As such, the only way to be effective at using ",(0,i.jsx)(t.code,{children:"auto"})," is to understand how it works. This section explains template type deduction, building ",(0,i.jsx)(t.code,{children:"auto"})," on top of it, and the tangent of ",(0,i.jsx)(t.code,{children:"decltype"}),". Scott also explains how we can force compilers to make the results of their type deduction visible, and allows us to guarantee that the compilers are deducing the types we want them to be deducing."]}),"\n",(0,i.jsx)(t.h3,{id:"understanding-template-type-deduction",children:"Understanding template type deduction"}),"\n",(0,i.jsxs)(t.p,{children:["C++ developers are guilty of using templates without knowing how it works. The reality is that the rules for template type deduction are employed by the ",(0,i.jsx)(t.code,{children:"auto"})," keyword."]})]})}function h(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var o=n(6540);const i={},d=o.createContext(i);function s(e){const t=o.useContext(d);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(d.Provider,{value:t},e.children)}}}]);